import kubernetes_asyncio.client
import typing
class CoreV1ComponentStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ComponentStatusList:
        return await self.client.list_component_status(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ComponentStatus:
        return await self.client.read_component_status(name=name, pretty=pretty)
class CoreV1ConfigMapForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ConfigMapList:
        return await self.client.list_config_map_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class CoreV1EndpointsForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1EndpointsList:
        return await self.client.list_endpoints_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class CoreV1EventForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.CoreV1EventList:
        return await self.client.list_event_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class CoreV1LimitRangeForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1LimitRangeList:
        return await self.client.list_limit_range_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class CoreV1NamespaceManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1NamespaceList:
        return await self.client.list_namespace(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1Namespace, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Namespace:
        return await self.client.create_namespace(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Namespace:
        return await self.client.read_namespace(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1Namespace, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Namespace:
        return await self.client.replace_namespace(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespace(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1Namespace:
        return await self.client.patch_namespace(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1NamespacedBindingManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1Binding, *, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Binding:
        return await self.client.create_namespaced_binding(namespace=namespace, body=body, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, pretty=pretty)
class CoreV1NamespacedConfigMapManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ConfigMapList:
        return await self.client.list_namespaced_config_map(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1ConfigMap, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ConfigMap:
        return await self.client.create_namespaced_config_map(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ConfigMap:
        return await self.client.read_namespaced_config_map(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1ConfigMap, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ConfigMap:
        return await self.client.replace_namespaced_config_map(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_config_map(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ConfigMap:
        return await self.client.patch_namespaced_config_map(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1CollectionNamespacedConfigMapManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_config_map(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class CoreV1NamespacedEndpointsManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1EndpointsList:
        return await self.client.list_namespaced_endpoints(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1Endpoints, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Endpoints:
        return await self.client.create_namespaced_endpoints(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Endpoints:
        return await self.client.read_namespaced_endpoints(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1Endpoints, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Endpoints:
        return await self.client.replace_namespaced_endpoints(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_endpoints(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1Endpoints:
        return await self.client.patch_namespaced_endpoints(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1CollectionNamespacedEndpointsManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_endpoints(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class CoreV1NamespacedEventManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.CoreV1EventList:
        return await self.client.list_namespaced_event(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.CoreV1Event, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.CoreV1Event:
        return await self.client.create_namespaced_event(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.CoreV1Event:
        return await self.client.read_namespaced_event(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.CoreV1Event, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.CoreV1Event:
        return await self.client.replace_namespaced_event(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_event(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.CoreV1Event:
        return await self.client.patch_namespaced_event(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1CollectionNamespacedEventManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_event(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class CoreV1NamespacedLimitRangeManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1LimitRangeList:
        return await self.client.list_namespaced_limit_range(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1LimitRange, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1LimitRange:
        return await self.client.create_namespaced_limit_range(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1LimitRange:
        return await self.client.read_namespaced_limit_range(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1LimitRange, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1LimitRange:
        return await self.client.replace_namespaced_limit_range(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_limit_range(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1LimitRange:
        return await self.client.patch_namespaced_limit_range(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1CollectionNamespacedLimitRangeManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_limit_range(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class CoreV1NamespacedPersistentVolumeClaimManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1PersistentVolumeClaimList:
        return await self.client.list_namespaced_persistent_volume_claim(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1PersistentVolumeClaim, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PersistentVolumeClaim:
        return await self.client.create_namespaced_persistent_volume_claim(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PersistentVolumeClaim:
        return await self.client.read_namespaced_persistent_volume_claim(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1PersistentVolumeClaim, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PersistentVolumeClaim:
        return await self.client.replace_namespaced_persistent_volume_claim(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PersistentVolumeClaim:
        return await self.client.delete_namespaced_persistent_volume_claim(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1PersistentVolumeClaim:
        return await self.client.patch_namespaced_persistent_volume_claim(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1CollectionNamespacedPersistentVolumeClaimManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_persistent_volume_claim(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class CoreV1NamespacedPersistentVolumeClaimStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PersistentVolumeClaim:
        return await self.client.read_namespaced_persistent_volume_claim_status(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1PersistentVolumeClaim, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PersistentVolumeClaim:
        return await self.client.replace_namespaced_persistent_volume_claim_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1PersistentVolumeClaim:
        return await self.client.patch_namespaced_persistent_volume_claim_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1NamespacedPodManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1PodList:
        return await self.client.list_namespaced_pod(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1Pod, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Pod:
        return await self.client.create_namespaced_pod(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Pod:
        return await self.client.read_namespaced_pod(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1Pod, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Pod:
        return await self.client.replace_namespaced_pod(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Pod:
        return await self.client.delete_namespaced_pod(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1Pod:
        return await self.client.patch_namespaced_pod(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1CollectionNamespacedPodManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_pod(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class CoreV1GetNamespacedPodAttachManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, *, container: typing.Optional[str] = None, stderr: typing.Optional[bool] = None, stdin: typing.Optional[bool] = None, stdout: typing.Optional[bool] = None, tty: typing.Optional[bool] = None) -> str:
        return await self.client.connect_get_namespaced_pod_attach(name=name, namespace=namespace, container=container, stderr=stderr, stdin=stdin, stdout=stdout, tty=tty)
class CoreV1PostNamespacedPodAttachManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, *, container: typing.Optional[str] = None, stderr: typing.Optional[bool] = None, stdin: typing.Optional[bool] = None, stdout: typing.Optional[bool] = None, tty: typing.Optional[bool] = None) -> str:
        return await self.client.connect_post_namespaced_pod_attach(name=name, namespace=namespace, container=container, stderr=stderr, stdin=stdin, stdout=stdout, tty=tty)
class CoreV1NamespacedPodBindingManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def create(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1Binding, *, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Binding:
        return await self.client.create_namespaced_pod_binding(name=name, namespace=namespace, body=body, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, pretty=pretty)
class CoreV1NamespacedPodEphemeralcontainersManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Pod:
        return await self.client.read_namespaced_pod_ephemeralcontainers(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1Pod, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Pod:
        return await self.client.replace_namespaced_pod_ephemeralcontainers(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1Pod:
        return await self.client.patch_namespaced_pod_ephemeralcontainers(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1NamespacedPodEvictionManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def create(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1Eviction, *, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Eviction:
        return await self.client.create_namespaced_pod_eviction(name=name, namespace=namespace, body=body, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, pretty=pretty)
class CoreV1GetNamespacedPodExecManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, *, command: typing.Optional[str] = None, container: typing.Optional[str] = None, stderr: typing.Optional[bool] = None, stdin: typing.Optional[bool] = None, stdout: typing.Optional[bool] = None, tty: typing.Optional[bool] = None) -> str:
        return await self.client.connect_get_namespaced_pod_exec(name=name, namespace=namespace, command=command, container=container, stderr=stderr, stdin=stdin, stdout=stdout, tty=tty)
class CoreV1PostNamespacedPodExecManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, *, command: typing.Optional[str] = None, container: typing.Optional[str] = None, stderr: typing.Optional[bool] = None, stdin: typing.Optional[bool] = None, stdout: typing.Optional[bool] = None, tty: typing.Optional[bool] = None) -> str:
        return await self.client.connect_post_namespaced_pod_exec(name=name, namespace=namespace, command=command, container=container, stderr=stderr, stdin=stdin, stdout=stdout, tty=tty)
class CoreV1NamespacedPodLogManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, container: typing.Optional[str] = None, follow: typing.Optional[bool] = None, insecure_skip_tls_verify_backend: typing.Optional[bool] = None, limit_bytes: typing.Optional[int] = None, pretty: typing.Optional[str] = None, previous: typing.Optional[bool] = None, since_seconds: typing.Optional[int] = None, tail_lines: typing.Optional[int] = None, timestamps: typing.Optional[bool] = None) -> str:
        return await self.client.read_namespaced_pod_log(name=name, namespace=namespace, container=container, follow=follow, insecure_skip_tls_verify_backend=insecure_skip_tls_verify_backend, limit_bytes=limit_bytes, pretty=pretty, previous=previous, since_seconds=since_seconds, tail_lines=tail_lines, timestamps=timestamps)
class CoreV1GetNamespacedPodPortforwardManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, *, ports: typing.Optional[int] = None) -> str:
        return await self.client.connect_get_namespaced_pod_portforward(name=name, namespace=namespace, ports=ports)
class CoreV1PostNamespacedPodPortforwardManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, *, ports: typing.Optional[int] = None) -> str:
        return await self.client.connect_post_namespaced_pod_portforward(name=name, namespace=namespace, ports=ports)
class CoreV1GetNamespacedPodProxyManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, *, path: typing.Optional[str] = None) -> str:
        return await self.client.connect_get_namespaced_pod_proxy(name=name, namespace=namespace, path=path)
class CoreV1PutNamespacedPodProxyManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, *, path: typing.Optional[str] = None) -> str:
        return await self.client.connect_put_namespaced_pod_proxy(name=name, namespace=namespace, path=path)
class CoreV1PostNamespacedPodProxyManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, *, path: typing.Optional[str] = None) -> str:
        return await self.client.connect_post_namespaced_pod_proxy(name=name, namespace=namespace, path=path)
class CoreV1DeleteNamespacedPodProxyManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, *, path: typing.Optional[str] = None) -> str:
        return await self.client.connect_delete_namespaced_pod_proxy(name=name, namespace=namespace, path=path)
class CoreV1OptionsNamespacedPodProxyManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, *, path: typing.Optional[str] = None) -> str:
        return await self.client.connect_options_namespaced_pod_proxy(name=name, namespace=namespace, path=path)
class CoreV1HeadNamespacedPodProxyManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, *, path: typing.Optional[str] = None) -> str:
        return await self.client.connect_head_namespaced_pod_proxy(name=name, namespace=namespace, path=path)
class CoreV1PatchNamespacedPodProxyManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, *, path: typing.Optional[str] = None) -> str:
        return await self.client.connect_patch_namespaced_pod_proxy(name=name, namespace=namespace, path=path)
class CoreV1GetNamespacedPodProxyWithPathManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, path: str, *, path2: typing.Optional[str] = None) -> str:
        return await self.client.connect_get_namespaced_pod_proxy_with_path(name=name, namespace=namespace, path=path, path2=path2)
class CoreV1PutNamespacedPodProxyWithPathManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, path: str, *, path2: typing.Optional[str] = None) -> str:
        return await self.client.connect_put_namespaced_pod_proxy_with_path(name=name, namespace=namespace, path=path, path2=path2)
class CoreV1PostNamespacedPodProxyWithPathManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, path: str, *, path2: typing.Optional[str] = None) -> str:
        return await self.client.connect_post_namespaced_pod_proxy_with_path(name=name, namespace=namespace, path=path, path2=path2)
class CoreV1DeleteNamespacedPodProxyWithPathManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, path: str, *, path2: typing.Optional[str] = None) -> str:
        return await self.client.connect_delete_namespaced_pod_proxy_with_path(name=name, namespace=namespace, path=path, path2=path2)
class CoreV1OptionsNamespacedPodProxyWithPathManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, path: str, *, path2: typing.Optional[str] = None) -> str:
        return await self.client.connect_options_namespaced_pod_proxy_with_path(name=name, namespace=namespace, path=path, path2=path2)
class CoreV1HeadNamespacedPodProxyWithPathManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, path: str, *, path2: typing.Optional[str] = None) -> str:
        return await self.client.connect_head_namespaced_pod_proxy_with_path(name=name, namespace=namespace, path=path, path2=path2)
class CoreV1PatchNamespacedPodProxyWithPathManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, path: str, *, path2: typing.Optional[str] = None) -> str:
        return await self.client.connect_patch_namespaced_pod_proxy_with_path(name=name, namespace=namespace, path=path, path2=path2)
class CoreV1NamespacedPodStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Pod:
        return await self.client.read_namespaced_pod_status(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1Pod, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Pod:
        return await self.client.replace_namespaced_pod_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1Pod:
        return await self.client.patch_namespaced_pod_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1NamespacedPodTemplateManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1PodTemplateList:
        return await self.client.list_namespaced_pod_template(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1PodTemplate, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PodTemplate:
        return await self.client.create_namespaced_pod_template(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PodTemplate:
        return await self.client.read_namespaced_pod_template(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1PodTemplate, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PodTemplate:
        return await self.client.replace_namespaced_pod_template(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PodTemplate:
        return await self.client.delete_namespaced_pod_template(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1PodTemplate:
        return await self.client.patch_namespaced_pod_template(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1CollectionNamespacedPodTemplateManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_pod_template(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class CoreV1NamespacedReplicationControllerManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ReplicationControllerList:
        return await self.client.list_namespaced_replication_controller(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1ReplicationController, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ReplicationController:
        return await self.client.create_namespaced_replication_controller(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ReplicationController:
        return await self.client.read_namespaced_replication_controller(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1ReplicationController, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ReplicationController:
        return await self.client.replace_namespaced_replication_controller(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_replication_controller(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ReplicationController:
        return await self.client.patch_namespaced_replication_controller(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1CollectionNamespacedReplicationControllerManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_replication_controller(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class CoreV1NamespacedReplicationControllerScaleManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Scale:
        return await self.client.read_namespaced_replication_controller_scale(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1Scale, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Scale:
        return await self.client.replace_namespaced_replication_controller_scale(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1Scale:
        return await self.client.patch_namespaced_replication_controller_scale(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1NamespacedReplicationControllerStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ReplicationController:
        return await self.client.read_namespaced_replication_controller_status(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1ReplicationController, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ReplicationController:
        return await self.client.replace_namespaced_replication_controller_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ReplicationController:
        return await self.client.patch_namespaced_replication_controller_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1NamespacedResourceQuotaManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ResourceQuotaList:
        return await self.client.list_namespaced_resource_quota(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1ResourceQuota, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ResourceQuota:
        return await self.client.create_namespaced_resource_quota(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ResourceQuota:
        return await self.client.read_namespaced_resource_quota(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1ResourceQuota, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ResourceQuota:
        return await self.client.replace_namespaced_resource_quota(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ResourceQuota:
        return await self.client.delete_namespaced_resource_quota(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ResourceQuota:
        return await self.client.patch_namespaced_resource_quota(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1CollectionNamespacedResourceQuotaManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_resource_quota(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class CoreV1NamespacedResourceQuotaStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ResourceQuota:
        return await self.client.read_namespaced_resource_quota_status(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1ResourceQuota, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ResourceQuota:
        return await self.client.replace_namespaced_resource_quota_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ResourceQuota:
        return await self.client.patch_namespaced_resource_quota_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1NamespacedSecretManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1SecretList:
        return await self.client.list_namespaced_secret(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1Secret, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Secret:
        return await self.client.create_namespaced_secret(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Secret:
        return await self.client.read_namespaced_secret(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1Secret, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Secret:
        return await self.client.replace_namespaced_secret(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_secret(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1Secret:
        return await self.client.patch_namespaced_secret(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1CollectionNamespacedSecretManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_secret(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class CoreV1NamespacedServiceAccountManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ServiceAccountList:
        return await self.client.list_namespaced_service_account(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1ServiceAccount, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ServiceAccount:
        return await self.client.create_namespaced_service_account(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ServiceAccount:
        return await self.client.read_namespaced_service_account(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1ServiceAccount, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ServiceAccount:
        return await self.client.replace_namespaced_service_account(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ServiceAccount:
        return await self.client.delete_namespaced_service_account(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ServiceAccount:
        return await self.client.patch_namespaced_service_account(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1CollectionNamespacedServiceAccountManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_service_account(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class CoreV1NamespacedServiceAccountTokenManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def create(self, name: str, namespace: str, body: kubernetes_asyncio.client.AuthenticationV1TokenRequest, *, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.AuthenticationV1TokenRequest:
        return await self.client.create_namespaced_service_account_token(name=name, namespace=namespace, body=body, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, pretty=pretty)
class CoreV1NamespacedServiceManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ServiceList:
        return await self.client.list_namespaced_service(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1Service, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Service:
        return await self.client.create_namespaced_service(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Service:
        return await self.client.read_namespaced_service(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1Service, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Service:
        return await self.client.replace_namespaced_service(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Service:
        return await self.client.delete_namespaced_service(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1Service:
        return await self.client.patch_namespaced_service(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1CollectionNamespacedServiceManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_service(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class CoreV1GetNamespacedServiceProxyManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, *, path: typing.Optional[str] = None) -> str:
        return await self.client.connect_get_namespaced_service_proxy(name=name, namespace=namespace, path=path)
class CoreV1PutNamespacedServiceProxyManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, *, path: typing.Optional[str] = None) -> str:
        return await self.client.connect_put_namespaced_service_proxy(name=name, namespace=namespace, path=path)
class CoreV1PostNamespacedServiceProxyManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, *, path: typing.Optional[str] = None) -> str:
        return await self.client.connect_post_namespaced_service_proxy(name=name, namespace=namespace, path=path)
class CoreV1DeleteNamespacedServiceProxyManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, *, path: typing.Optional[str] = None) -> str:
        return await self.client.connect_delete_namespaced_service_proxy(name=name, namespace=namespace, path=path)
class CoreV1OptionsNamespacedServiceProxyManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, *, path: typing.Optional[str] = None) -> str:
        return await self.client.connect_options_namespaced_service_proxy(name=name, namespace=namespace, path=path)
class CoreV1HeadNamespacedServiceProxyManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, *, path: typing.Optional[str] = None) -> str:
        return await self.client.connect_head_namespaced_service_proxy(name=name, namespace=namespace, path=path)
class CoreV1PatchNamespacedServiceProxyManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, *, path: typing.Optional[str] = None) -> str:
        return await self.client.connect_patch_namespaced_service_proxy(name=name, namespace=namespace, path=path)
class CoreV1GetNamespacedServiceProxyWithPathManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, path: str, *, path2: typing.Optional[str] = None) -> str:
        return await self.client.connect_get_namespaced_service_proxy_with_path(name=name, namespace=namespace, path=path, path2=path2)
class CoreV1PutNamespacedServiceProxyWithPathManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, path: str, *, path2: typing.Optional[str] = None) -> str:
        return await self.client.connect_put_namespaced_service_proxy_with_path(name=name, namespace=namespace, path=path, path2=path2)
class CoreV1PostNamespacedServiceProxyWithPathManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, path: str, *, path2: typing.Optional[str] = None) -> str:
        return await self.client.connect_post_namespaced_service_proxy_with_path(name=name, namespace=namespace, path=path, path2=path2)
class CoreV1DeleteNamespacedServiceProxyWithPathManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, path: str, *, path2: typing.Optional[str] = None) -> str:
        return await self.client.connect_delete_namespaced_service_proxy_with_path(name=name, namespace=namespace, path=path, path2=path2)
class CoreV1OptionsNamespacedServiceProxyWithPathManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, path: str, *, path2: typing.Optional[str] = None) -> str:
        return await self.client.connect_options_namespaced_service_proxy_with_path(name=name, namespace=namespace, path=path, path2=path2)
class CoreV1HeadNamespacedServiceProxyWithPathManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, path: str, *, path2: typing.Optional[str] = None) -> str:
        return await self.client.connect_head_namespaced_service_proxy_with_path(name=name, namespace=namespace, path=path, path2=path2)
class CoreV1PatchNamespacedServiceProxyWithPathManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, namespace: str, path: str, *, path2: typing.Optional[str] = None) -> str:
        return await self.client.connect_patch_namespaced_service_proxy_with_path(name=name, namespace=namespace, path=path, path2=path2)
class CoreV1NamespacedServiceStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Service:
        return await self.client.read_namespaced_service_status(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1Service, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Service:
        return await self.client.replace_namespaced_service_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1Service:
        return await self.client.patch_namespaced_service_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1NamespaceFinalizeManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1Namespace, *, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Namespace:
        return await self.client.replace_namespace_finalize(name=name, body=body, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, pretty=pretty)
class CoreV1NamespaceStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Namespace:
        return await self.client.read_namespace_status(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1Namespace, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Namespace:
        return await self.client.replace_namespace_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1Namespace:
        return await self.client.patch_namespace_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1NodeManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1NodeList:
        return await self.client.list_node(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1Node, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Node:
        return await self.client.create_node(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Node:
        return await self.client.read_node(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1Node, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Node:
        return await self.client.replace_node(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_node(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1Node:
        return await self.client.patch_node(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1CollectionNodeManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def delete(self, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_node(pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class CoreV1GetNodeProxyManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, *, path: typing.Optional[str] = None) -> str:
        return await self.client.connect_get_node_proxy(name=name, path=path)
class CoreV1PutNodeProxyManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, *, path: typing.Optional[str] = None) -> str:
        return await self.client.connect_put_node_proxy(name=name, path=path)
class CoreV1PostNodeProxyManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, *, path: typing.Optional[str] = None) -> str:
        return await self.client.connect_post_node_proxy(name=name, path=path)
class CoreV1DeleteNodeProxyManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, *, path: typing.Optional[str] = None) -> str:
        return await self.client.connect_delete_node_proxy(name=name, path=path)
class CoreV1OptionsNodeProxyManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, *, path: typing.Optional[str] = None) -> str:
        return await self.client.connect_options_node_proxy(name=name, path=path)
class CoreV1HeadNodeProxyManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, *, path: typing.Optional[str] = None) -> str:
        return await self.client.connect_head_node_proxy(name=name, path=path)
class CoreV1PatchNodeProxyManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, *, path: typing.Optional[str] = None) -> str:
        return await self.client.connect_patch_node_proxy(name=name, path=path)
class CoreV1GetNodeProxyWithPathManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, path: str, *, path2: typing.Optional[str] = None) -> str:
        return await self.client.connect_get_node_proxy_with_path(name=name, path=path, path2=path2)
class CoreV1PutNodeProxyWithPathManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, path: str, *, path2: typing.Optional[str] = None) -> str:
        return await self.client.connect_put_node_proxy_with_path(name=name, path=path, path2=path2)
class CoreV1PostNodeProxyWithPathManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, path: str, *, path2: typing.Optional[str] = None) -> str:
        return await self.client.connect_post_node_proxy_with_path(name=name, path=path, path2=path2)
class CoreV1DeleteNodeProxyWithPathManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, path: str, *, path2: typing.Optional[str] = None) -> str:
        return await self.client.connect_delete_node_proxy_with_path(name=name, path=path, path2=path2)
class CoreV1OptionsNodeProxyWithPathManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, path: str, *, path2: typing.Optional[str] = None) -> str:
        return await self.client.connect_options_node_proxy_with_path(name=name, path=path, path2=path2)
class CoreV1HeadNodeProxyWithPathManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, path: str, *, path2: typing.Optional[str] = None) -> str:
        return await self.client.connect_head_node_proxy_with_path(name=name, path=path, path2=path2)
class CoreV1PatchNodeProxyWithPathManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def connect(self, name: str, path: str, *, path2: typing.Optional[str] = None) -> str:
        return await self.client.connect_patch_node_proxy_with_path(name=name, path=path, path2=path2)
class CoreV1NodeStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Node:
        return await self.client.read_node_status(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1Node, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Node:
        return await self.client.replace_node_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1Node:
        return await self.client.patch_node_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1PersistentVolumeClaimForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1PersistentVolumeClaimList:
        return await self.client.list_persistent_volume_claim_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class CoreV1PersistentVolumeManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1PersistentVolumeList:
        return await self.client.list_persistent_volume(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1PersistentVolume, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PersistentVolume:
        return await self.client.create_persistent_volume(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PersistentVolume:
        return await self.client.read_persistent_volume(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1PersistentVolume, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PersistentVolume:
        return await self.client.replace_persistent_volume(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PersistentVolume:
        return await self.client.delete_persistent_volume(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1PersistentVolume:
        return await self.client.patch_persistent_volume(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1CollectionPersistentVolumeManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def delete(self, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_persistent_volume(pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class CoreV1PersistentVolumeStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PersistentVolume:
        return await self.client.read_persistent_volume_status(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1PersistentVolume, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PersistentVolume:
        return await self.client.replace_persistent_volume_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1PersistentVolume:
        return await self.client.patch_persistent_volume_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoreV1PodForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1PodList:
        return await self.client.list_pod_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class CoreV1PodTemplateForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1PodTemplateList:
        return await self.client.list_pod_template_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class CoreV1ReplicationControllerForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ReplicationControllerList:
        return await self.client.list_replication_controller_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class CoreV1ResourceQuotaForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ResourceQuotaList:
        return await self.client.list_resource_quota_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class CoreV1SecretForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1SecretList:
        return await self.client.list_secret_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class CoreV1ServiceAccountForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ServiceAccountList:
        return await self.client.list_service_account_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class CoreV1ServiceForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.CoreV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ServiceList:
        return await self.client.list_service_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class AdmissionregistrationV1MutatingWebhookConfigurationManager:
    def __init__(self, client: kubernetes_asyncio.client.AdmissionregistrationV1Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1MutatingWebhookConfigurationList:
        return await self.client.list_mutating_webhook_configuration(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1MutatingWebhookConfiguration, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1MutatingWebhookConfiguration:
        return await self.client.create_mutating_webhook_configuration(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1MutatingWebhookConfiguration:
        return await self.client.read_mutating_webhook_configuration(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1MutatingWebhookConfiguration, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1MutatingWebhookConfiguration:
        return await self.client.replace_mutating_webhook_configuration(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_mutating_webhook_configuration(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1MutatingWebhookConfiguration:
        return await self.client.patch_mutating_webhook_configuration(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class AdmissionregistrationV1CollectionMutatingWebhookConfigurationManager:
    def __init__(self, client: kubernetes_asyncio.client.AdmissionregistrationV1Api) -> None:
        self.client = client
    async def delete(self, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_mutating_webhook_configuration(pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class AdmissionregistrationV1ValidatingWebhookConfigurationManager:
    def __init__(self, client: kubernetes_asyncio.client.AdmissionregistrationV1Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ValidatingWebhookConfigurationList:
        return await self.client.list_validating_webhook_configuration(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1ValidatingWebhookConfiguration, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ValidatingWebhookConfiguration:
        return await self.client.create_validating_webhook_configuration(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ValidatingWebhookConfiguration:
        return await self.client.read_validating_webhook_configuration(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1ValidatingWebhookConfiguration, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ValidatingWebhookConfiguration:
        return await self.client.replace_validating_webhook_configuration(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_validating_webhook_configuration(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ValidatingWebhookConfiguration:
        return await self.client.patch_validating_webhook_configuration(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class AdmissionregistrationV1CollectionValidatingWebhookConfigurationManager:
    def __init__(self, client: kubernetes_asyncio.client.AdmissionregistrationV1Api) -> None:
        self.client = client
    async def delete(self, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_validating_webhook_configuration(pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class ApiextensionsV1CustomResourceDefinitionManager:
    def __init__(self, client: kubernetes_asyncio.client.ApiextensionsV1Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1CustomResourceDefinitionList:
        return await self.client.list_custom_resource_definition(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1CustomResourceDefinition, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CustomResourceDefinition:
        return await self.client.create_custom_resource_definition(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CustomResourceDefinition:
        return await self.client.read_custom_resource_definition(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1CustomResourceDefinition, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CustomResourceDefinition:
        return await self.client.replace_custom_resource_definition(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_custom_resource_definition(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1CustomResourceDefinition:
        return await self.client.patch_custom_resource_definition(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class ApiextensionsV1CollectionCustomResourceDefinitionManager:
    def __init__(self, client: kubernetes_asyncio.client.ApiextensionsV1Api) -> None:
        self.client = client
    async def delete(self, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_custom_resource_definition(pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class ApiextensionsV1CustomResourceDefinitionStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.ApiextensionsV1Api) -> None:
        self.client = client
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CustomResourceDefinition:
        return await self.client.read_custom_resource_definition_status(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1CustomResourceDefinition, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CustomResourceDefinition:
        return await self.client.replace_custom_resource_definition_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1CustomResourceDefinition:
        return await self.client.patch_custom_resource_definition_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class ApiregistrationV1ApiServiceManager:
    def __init__(self, client: kubernetes_asyncio.client.ApiregistrationV1Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1APIServiceList:
        return await self.client.list_api_service(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1APIService, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1APIService:
        return await self.client.create_api_service(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1APIService:
        return await self.client.read_api_service(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1APIService, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1APIService:
        return await self.client.replace_api_service(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_api_service(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1APIService:
        return await self.client.patch_api_service(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class ApiregistrationV1CollectionApiServiceManager:
    def __init__(self, client: kubernetes_asyncio.client.ApiregistrationV1Api) -> None:
        self.client = client
    async def delete(self, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_api_service(pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class ApiregistrationV1ApiServiceStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.ApiregistrationV1Api) -> None:
        self.client = client
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1APIService:
        return await self.client.read_api_service_status(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1APIService, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1APIService:
        return await self.client.replace_api_service_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1APIService:
        return await self.client.patch_api_service_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class AppsV1ControllerRevisionForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.AppsV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ControllerRevisionList:
        return await self.client.list_controller_revision_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class AppsV1DaemonSetForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.AppsV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1DaemonSetList:
        return await self.client.list_daemon_set_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class AppsV1DeploymentForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.AppsV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1DeploymentList:
        return await self.client.list_deployment_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class AppsV1NamespacedControllerRevisionManager:
    def __init__(self, client: kubernetes_asyncio.client.AppsV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ControllerRevisionList:
        return await self.client.list_namespaced_controller_revision(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1ControllerRevision, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ControllerRevision:
        return await self.client.create_namespaced_controller_revision(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ControllerRevision:
        return await self.client.read_namespaced_controller_revision(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1ControllerRevision, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ControllerRevision:
        return await self.client.replace_namespaced_controller_revision(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_controller_revision(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ControllerRevision:
        return await self.client.patch_namespaced_controller_revision(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class AppsV1CollectionNamespacedControllerRevisionManager:
    def __init__(self, client: kubernetes_asyncio.client.AppsV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_controller_revision(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class AppsV1NamespacedDaemonSetManager:
    def __init__(self, client: kubernetes_asyncio.client.AppsV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1DaemonSetList:
        return await self.client.list_namespaced_daemon_set(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1DaemonSet, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1DaemonSet:
        return await self.client.create_namespaced_daemon_set(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1DaemonSet:
        return await self.client.read_namespaced_daemon_set(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1DaemonSet, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1DaemonSet:
        return await self.client.replace_namespaced_daemon_set(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_daemon_set(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1DaemonSet:
        return await self.client.patch_namespaced_daemon_set(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class AppsV1CollectionNamespacedDaemonSetManager:
    def __init__(self, client: kubernetes_asyncio.client.AppsV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_daemon_set(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class AppsV1NamespacedDaemonSetStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.AppsV1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1DaemonSet:
        return await self.client.read_namespaced_daemon_set_status(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1DaemonSet, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1DaemonSet:
        return await self.client.replace_namespaced_daemon_set_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1DaemonSet:
        return await self.client.patch_namespaced_daemon_set_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class AppsV1NamespacedDeploymentManager:
    def __init__(self, client: kubernetes_asyncio.client.AppsV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1DeploymentList:
        return await self.client.list_namespaced_deployment(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1Deployment, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Deployment:
        return await self.client.create_namespaced_deployment(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Deployment:
        return await self.client.read_namespaced_deployment(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1Deployment, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Deployment:
        return await self.client.replace_namespaced_deployment(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_deployment(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1Deployment:
        return await self.client.patch_namespaced_deployment(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class AppsV1CollectionNamespacedDeploymentManager:
    def __init__(self, client: kubernetes_asyncio.client.AppsV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_deployment(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class AppsV1NamespacedDeploymentScaleManager:
    def __init__(self, client: kubernetes_asyncio.client.AppsV1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Scale:
        return await self.client.read_namespaced_deployment_scale(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1Scale, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Scale:
        return await self.client.replace_namespaced_deployment_scale(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1Scale:
        return await self.client.patch_namespaced_deployment_scale(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class AppsV1NamespacedDeploymentStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.AppsV1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Deployment:
        return await self.client.read_namespaced_deployment_status(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1Deployment, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Deployment:
        return await self.client.replace_namespaced_deployment_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1Deployment:
        return await self.client.patch_namespaced_deployment_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class AppsV1NamespacedReplicaSetManager:
    def __init__(self, client: kubernetes_asyncio.client.AppsV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ReplicaSetList:
        return await self.client.list_namespaced_replica_set(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1ReplicaSet, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ReplicaSet:
        return await self.client.create_namespaced_replica_set(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ReplicaSet:
        return await self.client.read_namespaced_replica_set(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1ReplicaSet, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ReplicaSet:
        return await self.client.replace_namespaced_replica_set(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_replica_set(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ReplicaSet:
        return await self.client.patch_namespaced_replica_set(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class AppsV1CollectionNamespacedReplicaSetManager:
    def __init__(self, client: kubernetes_asyncio.client.AppsV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_replica_set(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class AppsV1NamespacedReplicaSetScaleManager:
    def __init__(self, client: kubernetes_asyncio.client.AppsV1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Scale:
        return await self.client.read_namespaced_replica_set_scale(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1Scale, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Scale:
        return await self.client.replace_namespaced_replica_set_scale(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1Scale:
        return await self.client.patch_namespaced_replica_set_scale(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class AppsV1NamespacedReplicaSetStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.AppsV1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ReplicaSet:
        return await self.client.read_namespaced_replica_set_status(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1ReplicaSet, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ReplicaSet:
        return await self.client.replace_namespaced_replica_set_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ReplicaSet:
        return await self.client.patch_namespaced_replica_set_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class AppsV1NamespacedStatefulSetManager:
    def __init__(self, client: kubernetes_asyncio.client.AppsV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1StatefulSetList:
        return await self.client.list_namespaced_stateful_set(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1StatefulSet, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1StatefulSet:
        return await self.client.create_namespaced_stateful_set(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1StatefulSet:
        return await self.client.read_namespaced_stateful_set(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1StatefulSet, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1StatefulSet:
        return await self.client.replace_namespaced_stateful_set(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_stateful_set(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1StatefulSet:
        return await self.client.patch_namespaced_stateful_set(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class AppsV1CollectionNamespacedStatefulSetManager:
    def __init__(self, client: kubernetes_asyncio.client.AppsV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_stateful_set(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class AppsV1NamespacedStatefulSetScaleManager:
    def __init__(self, client: kubernetes_asyncio.client.AppsV1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Scale:
        return await self.client.read_namespaced_stateful_set_scale(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1Scale, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Scale:
        return await self.client.replace_namespaced_stateful_set_scale(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1Scale:
        return await self.client.patch_namespaced_stateful_set_scale(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class AppsV1NamespacedStatefulSetStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.AppsV1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1StatefulSet:
        return await self.client.read_namespaced_stateful_set_status(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1StatefulSet, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1StatefulSet:
        return await self.client.replace_namespaced_stateful_set_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1StatefulSet:
        return await self.client.patch_namespaced_stateful_set_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class AppsV1ReplicaSetForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.AppsV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ReplicaSetList:
        return await self.client.list_replica_set_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class AppsV1StatefulSetForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.AppsV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1StatefulSetList:
        return await self.client.list_stateful_set_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class AuthenticationV1TokenReviewManager:
    def __init__(self, client: kubernetes_asyncio.client.AuthenticationV1Api) -> None:
        self.client = client
    async def create(self, body: kubernetes_asyncio.client.V1TokenReview, *, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1TokenReview:
        return await self.client.create_token_review(body=body, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, pretty=pretty)
class AuthorizationV1NamespacedLocalSubjectAccessReviewManager:
    def __init__(self, client: kubernetes_asyncio.client.AuthorizationV1Api) -> None:
        self.client = client
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1LocalSubjectAccessReview, *, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1LocalSubjectAccessReview:
        return await self.client.create_namespaced_local_subject_access_review(namespace=namespace, body=body, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, pretty=pretty)
class AuthorizationV1SelfSubjectAccessReviewManager:
    def __init__(self, client: kubernetes_asyncio.client.AuthorizationV1Api) -> None:
        self.client = client
    async def create(self, body: kubernetes_asyncio.client.V1SelfSubjectAccessReview, *, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1SelfSubjectAccessReview:
        return await self.client.create_self_subject_access_review(body=body, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, pretty=pretty)
class AuthorizationV1SelfSubjectRulesReviewManager:
    def __init__(self, client: kubernetes_asyncio.client.AuthorizationV1Api) -> None:
        self.client = client
    async def create(self, body: kubernetes_asyncio.client.V1SelfSubjectRulesReview, *, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1SelfSubjectRulesReview:
        return await self.client.create_self_subject_rules_review(body=body, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, pretty=pretty)
class AuthorizationV1SubjectAccessReviewManager:
    def __init__(self, client: kubernetes_asyncio.client.AuthorizationV1Api) -> None:
        self.client = client
    async def create(self, body: kubernetes_asyncio.client.V1SubjectAccessReview, *, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1SubjectAccessReview:
        return await self.client.create_subject_access_review(body=body, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, pretty=pretty)
class AutoscalingV1HorizontalPodAutoscalerForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.AutoscalingV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1HorizontalPodAutoscalerList:
        return await self.client.list_horizontal_pod_autoscaler_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class AutoscalingV1NamespacedHorizontalPodAutoscalerManager:
    def __init__(self, client: kubernetes_asyncio.client.AutoscalingV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1HorizontalPodAutoscalerList:
        return await self.client.list_namespaced_horizontal_pod_autoscaler(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1HorizontalPodAutoscaler, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1HorizontalPodAutoscaler:
        return await self.client.create_namespaced_horizontal_pod_autoscaler(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1HorizontalPodAutoscaler:
        return await self.client.read_namespaced_horizontal_pod_autoscaler(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1HorizontalPodAutoscaler, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1HorizontalPodAutoscaler:
        return await self.client.replace_namespaced_horizontal_pod_autoscaler(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_horizontal_pod_autoscaler(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1HorizontalPodAutoscaler:
        return await self.client.patch_namespaced_horizontal_pod_autoscaler(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class AutoscalingV1CollectionNamespacedHorizontalPodAutoscalerManager:
    def __init__(self, client: kubernetes_asyncio.client.AutoscalingV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_horizontal_pod_autoscaler(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class AutoscalingV1NamespacedHorizontalPodAutoscalerStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.AutoscalingV1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1HorizontalPodAutoscaler:
        return await self.client.read_namespaced_horizontal_pod_autoscaler_status(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1HorizontalPodAutoscaler, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1HorizontalPodAutoscaler:
        return await self.client.replace_namespaced_horizontal_pod_autoscaler_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1HorizontalPodAutoscaler:
        return await self.client.patch_namespaced_horizontal_pod_autoscaler_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class AutoscalingV2HorizontalPodAutoscalerForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.AutoscalingV2Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V2HorizontalPodAutoscalerList:
        return await self.client.list_horizontal_pod_autoscaler_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class AutoscalingV2NamespacedHorizontalPodAutoscalerManager:
    def __init__(self, client: kubernetes_asyncio.client.AutoscalingV2Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V2HorizontalPodAutoscalerList:
        return await self.client.list_namespaced_horizontal_pod_autoscaler(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V2HorizontalPodAutoscaler, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V2HorizontalPodAutoscaler:
        return await self.client.create_namespaced_horizontal_pod_autoscaler(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V2HorizontalPodAutoscaler:
        return await self.client.read_namespaced_horizontal_pod_autoscaler(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V2HorizontalPodAutoscaler, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V2HorizontalPodAutoscaler:
        return await self.client.replace_namespaced_horizontal_pod_autoscaler(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_horizontal_pod_autoscaler(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V2HorizontalPodAutoscaler:
        return await self.client.patch_namespaced_horizontal_pod_autoscaler(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class AutoscalingV2CollectionNamespacedHorizontalPodAutoscalerManager:
    def __init__(self, client: kubernetes_asyncio.client.AutoscalingV2Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_horizontal_pod_autoscaler(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class AutoscalingV2NamespacedHorizontalPodAutoscalerStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.AutoscalingV2Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V2HorizontalPodAutoscaler:
        return await self.client.read_namespaced_horizontal_pod_autoscaler_status(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V2HorizontalPodAutoscaler, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V2HorizontalPodAutoscaler:
        return await self.client.replace_namespaced_horizontal_pod_autoscaler_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V2HorizontalPodAutoscaler:
        return await self.client.patch_namespaced_horizontal_pod_autoscaler_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class AutoscalingV2beta1HorizontalPodAutoscalerForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.AutoscalingV2beta1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V2beta1HorizontalPodAutoscalerList:
        return await self.client.list_horizontal_pod_autoscaler_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class AutoscalingV2beta1NamespacedHorizontalPodAutoscalerManager:
    def __init__(self, client: kubernetes_asyncio.client.AutoscalingV2beta1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V2beta1HorizontalPodAutoscalerList:
        return await self.client.list_namespaced_horizontal_pod_autoscaler(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V2beta1HorizontalPodAutoscaler, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V2beta1HorizontalPodAutoscaler:
        return await self.client.create_namespaced_horizontal_pod_autoscaler(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V2beta1HorizontalPodAutoscaler:
        return await self.client.read_namespaced_horizontal_pod_autoscaler(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V2beta1HorizontalPodAutoscaler, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V2beta1HorizontalPodAutoscaler:
        return await self.client.replace_namespaced_horizontal_pod_autoscaler(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_horizontal_pod_autoscaler(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V2beta1HorizontalPodAutoscaler:
        return await self.client.patch_namespaced_horizontal_pod_autoscaler(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class AutoscalingV2beta1CollectionNamespacedHorizontalPodAutoscalerManager:
    def __init__(self, client: kubernetes_asyncio.client.AutoscalingV2beta1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_horizontal_pod_autoscaler(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class AutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.AutoscalingV2beta1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V2beta1HorizontalPodAutoscaler:
        return await self.client.read_namespaced_horizontal_pod_autoscaler_status(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V2beta1HorizontalPodAutoscaler, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V2beta1HorizontalPodAutoscaler:
        return await self.client.replace_namespaced_horizontal_pod_autoscaler_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V2beta1HorizontalPodAutoscaler:
        return await self.client.patch_namespaced_horizontal_pod_autoscaler_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class AutoscalingV2beta2HorizontalPodAutoscalerForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.AutoscalingV2beta2Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V2beta2HorizontalPodAutoscalerList:
        return await self.client.list_horizontal_pod_autoscaler_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class AutoscalingV2beta2NamespacedHorizontalPodAutoscalerManager:
    def __init__(self, client: kubernetes_asyncio.client.AutoscalingV2beta2Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V2beta2HorizontalPodAutoscalerList:
        return await self.client.list_namespaced_horizontal_pod_autoscaler(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V2beta2HorizontalPodAutoscaler, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V2beta2HorizontalPodAutoscaler:
        return await self.client.create_namespaced_horizontal_pod_autoscaler(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V2beta2HorizontalPodAutoscaler:
        return await self.client.read_namespaced_horizontal_pod_autoscaler(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V2beta2HorizontalPodAutoscaler, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V2beta2HorizontalPodAutoscaler:
        return await self.client.replace_namespaced_horizontal_pod_autoscaler(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_horizontal_pod_autoscaler(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V2beta2HorizontalPodAutoscaler:
        return await self.client.patch_namespaced_horizontal_pod_autoscaler(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class AutoscalingV2beta2CollectionNamespacedHorizontalPodAutoscalerManager:
    def __init__(self, client: kubernetes_asyncio.client.AutoscalingV2beta2Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_horizontal_pod_autoscaler(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class AutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.AutoscalingV2beta2Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V2beta2HorizontalPodAutoscaler:
        return await self.client.read_namespaced_horizontal_pod_autoscaler_status(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V2beta2HorizontalPodAutoscaler, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V2beta2HorizontalPodAutoscaler:
        return await self.client.replace_namespaced_horizontal_pod_autoscaler_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V2beta2HorizontalPodAutoscaler:
        return await self.client.patch_namespaced_horizontal_pod_autoscaler_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class BatchV1CronJobForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.BatchV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1CronJobList:
        return await self.client.list_cron_job_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class BatchV1JobForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.BatchV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1JobList:
        return await self.client.list_job_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class BatchV1NamespacedCronJobManager:
    def __init__(self, client: kubernetes_asyncio.client.BatchV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1CronJobList:
        return await self.client.list_namespaced_cron_job(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1CronJob, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CronJob:
        return await self.client.create_namespaced_cron_job(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CronJob:
        return await self.client.read_namespaced_cron_job(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1CronJob, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CronJob:
        return await self.client.replace_namespaced_cron_job(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_cron_job(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1CronJob:
        return await self.client.patch_namespaced_cron_job(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class BatchV1CollectionNamespacedCronJobManager:
    def __init__(self, client: kubernetes_asyncio.client.BatchV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_cron_job(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class BatchV1NamespacedCronJobStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.BatchV1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CronJob:
        return await self.client.read_namespaced_cron_job_status(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1CronJob, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CronJob:
        return await self.client.replace_namespaced_cron_job_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1CronJob:
        return await self.client.patch_namespaced_cron_job_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class BatchV1NamespacedJobManager:
    def __init__(self, client: kubernetes_asyncio.client.BatchV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1JobList:
        return await self.client.list_namespaced_job(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1Job, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Job:
        return await self.client.create_namespaced_job(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Job:
        return await self.client.read_namespaced_job(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1Job, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Job:
        return await self.client.replace_namespaced_job(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_job(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1Job:
        return await self.client.patch_namespaced_job(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class BatchV1CollectionNamespacedJobManager:
    def __init__(self, client: kubernetes_asyncio.client.BatchV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_job(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class BatchV1NamespacedJobStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.BatchV1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Job:
        return await self.client.read_namespaced_job_status(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1Job, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Job:
        return await self.client.replace_namespaced_job_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1Job:
        return await self.client.patch_namespaced_job_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class BatchV1beta1CronJobForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.BatchV1beta1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1CronJobList:
        return await self.client.list_cron_job_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class BatchV1beta1NamespacedCronJobManager:
    def __init__(self, client: kubernetes_asyncio.client.BatchV1beta1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1CronJobList:
        return await self.client.list_namespaced_cron_job(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1beta1CronJob, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1CronJob:
        return await self.client.create_namespaced_cron_job(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1CronJob:
        return await self.client.read_namespaced_cron_job(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1beta1CronJob, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1CronJob:
        return await self.client.replace_namespaced_cron_job(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_cron_job(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1CronJob:
        return await self.client.patch_namespaced_cron_job(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class BatchV1beta1CollectionNamespacedCronJobManager:
    def __init__(self, client: kubernetes_asyncio.client.BatchV1beta1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_cron_job(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class BatchV1beta1NamespacedCronJobStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.BatchV1beta1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1CronJob:
        return await self.client.read_namespaced_cron_job_status(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1beta1CronJob, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1CronJob:
        return await self.client.replace_namespaced_cron_job_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1CronJob:
        return await self.client.patch_namespaced_cron_job_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CertificatesV1CertificateSigningRequestManager:
    def __init__(self, client: kubernetes_asyncio.client.CertificatesV1Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1CertificateSigningRequestList:
        return await self.client.list_certificate_signing_request(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1CertificateSigningRequest, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CertificateSigningRequest:
        return await self.client.create_certificate_signing_request(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CertificateSigningRequest:
        return await self.client.read_certificate_signing_request(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1CertificateSigningRequest, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CertificateSigningRequest:
        return await self.client.replace_certificate_signing_request(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_certificate_signing_request(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1CertificateSigningRequest:
        return await self.client.patch_certificate_signing_request(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CertificatesV1CollectionCertificateSigningRequestManager:
    def __init__(self, client: kubernetes_asyncio.client.CertificatesV1Api) -> None:
        self.client = client
    async def delete(self, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_certificate_signing_request(pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class CertificatesV1CertificateSigningRequestApprovalManager:
    def __init__(self, client: kubernetes_asyncio.client.CertificatesV1Api) -> None:
        self.client = client
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CertificateSigningRequest:
        return await self.client.read_certificate_signing_request_approval(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1CertificateSigningRequest, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CertificateSigningRequest:
        return await self.client.replace_certificate_signing_request_approval(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1CertificateSigningRequest:
        return await self.client.patch_certificate_signing_request_approval(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CertificatesV1CertificateSigningRequestStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.CertificatesV1Api) -> None:
        self.client = client
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CertificateSigningRequest:
        return await self.client.read_certificate_signing_request_status(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1CertificateSigningRequest, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CertificateSigningRequest:
        return await self.client.replace_certificate_signing_request_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1CertificateSigningRequest:
        return await self.client.patch_certificate_signing_request_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoordinationV1LeaseForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.CoordinationV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1LeaseList:
        return await self.client.list_lease_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class CoordinationV1NamespacedLeaseManager:
    def __init__(self, client: kubernetes_asyncio.client.CoordinationV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1LeaseList:
        return await self.client.list_namespaced_lease(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1Lease, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Lease:
        return await self.client.create_namespaced_lease(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Lease:
        return await self.client.read_namespaced_lease(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1Lease, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Lease:
        return await self.client.replace_namespaced_lease(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_lease(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1Lease:
        return await self.client.patch_namespaced_lease(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class CoordinationV1CollectionNamespacedLeaseManager:
    def __init__(self, client: kubernetes_asyncio.client.CoordinationV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_lease(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class DiscoveryV1EndpointSliceForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.DiscoveryV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1EndpointSliceList:
        return await self.client.list_endpoint_slice_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class DiscoveryV1NamespacedEndpointSliceManager:
    def __init__(self, client: kubernetes_asyncio.client.DiscoveryV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1EndpointSliceList:
        return await self.client.list_namespaced_endpoint_slice(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1EndpointSlice, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1EndpointSlice:
        return await self.client.create_namespaced_endpoint_slice(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1EndpointSlice:
        return await self.client.read_namespaced_endpoint_slice(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1EndpointSlice, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1EndpointSlice:
        return await self.client.replace_namespaced_endpoint_slice(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_endpoint_slice(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1EndpointSlice:
        return await self.client.patch_namespaced_endpoint_slice(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class DiscoveryV1CollectionNamespacedEndpointSliceManager:
    def __init__(self, client: kubernetes_asyncio.client.DiscoveryV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_endpoint_slice(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class DiscoveryV1beta1EndpointSliceForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.DiscoveryV1beta1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1EndpointSliceList:
        return await self.client.list_endpoint_slice_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class DiscoveryV1beta1NamespacedEndpointSliceManager:
    def __init__(self, client: kubernetes_asyncio.client.DiscoveryV1beta1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1EndpointSliceList:
        return await self.client.list_namespaced_endpoint_slice(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1beta1EndpointSlice, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1EndpointSlice:
        return await self.client.create_namespaced_endpoint_slice(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1EndpointSlice:
        return await self.client.read_namespaced_endpoint_slice(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1beta1EndpointSlice, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1EndpointSlice:
        return await self.client.replace_namespaced_endpoint_slice(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_endpoint_slice(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1EndpointSlice:
        return await self.client.patch_namespaced_endpoint_slice(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class DiscoveryV1beta1CollectionNamespacedEndpointSliceManager:
    def __init__(self, client: kubernetes_asyncio.client.DiscoveryV1beta1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_endpoint_slice(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class EventsV1EventForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.EventsV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.EventsV1EventList:
        return await self.client.list_event_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class EventsV1NamespacedEventManager:
    def __init__(self, client: kubernetes_asyncio.client.EventsV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.EventsV1EventList:
        return await self.client.list_namespaced_event(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.EventsV1Event, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.EventsV1Event:
        return await self.client.create_namespaced_event(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.EventsV1Event:
        return await self.client.read_namespaced_event(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.EventsV1Event, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.EventsV1Event:
        return await self.client.replace_namespaced_event(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_event(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.EventsV1Event:
        return await self.client.patch_namespaced_event(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class EventsV1CollectionNamespacedEventManager:
    def __init__(self, client: kubernetes_asyncio.client.EventsV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_event(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class EventsV1beta1EventForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.EventsV1beta1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1EventList:
        return await self.client.list_event_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class EventsV1beta1NamespacedEventManager:
    def __init__(self, client: kubernetes_asyncio.client.EventsV1beta1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1EventList:
        return await self.client.list_namespaced_event(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1beta1Event, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1Event:
        return await self.client.create_namespaced_event(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1Event:
        return await self.client.read_namespaced_event(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1beta1Event, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1Event:
        return await self.client.replace_namespaced_event(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_event(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1Event:
        return await self.client.patch_namespaced_event(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class EventsV1beta1CollectionNamespacedEventManager:
    def __init__(self, client: kubernetes_asyncio.client.EventsV1beta1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_event(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class FlowcontrolApiserverV1beta1FlowSchemaManager:
    def __init__(self, client: kubernetes_asyncio.client.FlowcontrolApiserverV1beta1Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1FlowSchemaList:
        return await self.client.list_flow_schema(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1beta1FlowSchema, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1FlowSchema:
        return await self.client.create_flow_schema(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1FlowSchema:
        return await self.client.read_flow_schema(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1beta1FlowSchema, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1FlowSchema:
        return await self.client.replace_flow_schema(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_flow_schema(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1FlowSchema:
        return await self.client.patch_flow_schema(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class FlowcontrolApiserverV1beta1CollectionFlowSchemaManager:
    def __init__(self, client: kubernetes_asyncio.client.FlowcontrolApiserverV1beta1Api) -> None:
        self.client = client
    async def delete(self, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_flow_schema(pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class FlowcontrolApiserverV1beta1FlowSchemaStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.FlowcontrolApiserverV1beta1Api) -> None:
        self.client = client
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1FlowSchema:
        return await self.client.read_flow_schema_status(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1beta1FlowSchema, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1FlowSchema:
        return await self.client.replace_flow_schema_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1FlowSchema:
        return await self.client.patch_flow_schema_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class FlowcontrolApiserverV1beta1PriorityLevelConfigurationManager:
    def __init__(self, client: kubernetes_asyncio.client.FlowcontrolApiserverV1beta1Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1PriorityLevelConfigurationList:
        return await self.client.list_priority_level_configuration(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1beta1PriorityLevelConfiguration, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1PriorityLevelConfiguration:
        return await self.client.create_priority_level_configuration(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1PriorityLevelConfiguration:
        return await self.client.read_priority_level_configuration(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1beta1PriorityLevelConfiguration, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1PriorityLevelConfiguration:
        return await self.client.replace_priority_level_configuration(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_priority_level_configuration(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1PriorityLevelConfiguration:
        return await self.client.patch_priority_level_configuration(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class FlowcontrolApiserverV1beta1CollectionPriorityLevelConfigurationManager:
    def __init__(self, client: kubernetes_asyncio.client.FlowcontrolApiserverV1beta1Api) -> None:
        self.client = client
    async def delete(self, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_priority_level_configuration(pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class FlowcontrolApiserverV1beta1PriorityLevelConfigurationStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.FlowcontrolApiserverV1beta1Api) -> None:
        self.client = client
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1PriorityLevelConfiguration:
        return await self.client.read_priority_level_configuration_status(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1beta1PriorityLevelConfiguration, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1PriorityLevelConfiguration:
        return await self.client.replace_priority_level_configuration_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1PriorityLevelConfiguration:
        return await self.client.patch_priority_level_configuration_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class FlowcontrolApiserverV1beta2FlowSchemaManager:
    def __init__(self, client: kubernetes_asyncio.client.FlowcontrolApiserverV1beta2Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta2FlowSchemaList:
        return await self.client.list_flow_schema(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1beta2FlowSchema, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta2FlowSchema:
        return await self.client.create_flow_schema(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta2FlowSchema:
        return await self.client.read_flow_schema(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1beta2FlowSchema, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta2FlowSchema:
        return await self.client.replace_flow_schema(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_flow_schema(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta2FlowSchema:
        return await self.client.patch_flow_schema(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class FlowcontrolApiserverV1beta2CollectionFlowSchemaManager:
    def __init__(self, client: kubernetes_asyncio.client.FlowcontrolApiserverV1beta2Api) -> None:
        self.client = client
    async def delete(self, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_flow_schema(pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class FlowcontrolApiserverV1beta2FlowSchemaStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.FlowcontrolApiserverV1beta2Api) -> None:
        self.client = client
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta2FlowSchema:
        return await self.client.read_flow_schema_status(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1beta2FlowSchema, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta2FlowSchema:
        return await self.client.replace_flow_schema_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta2FlowSchema:
        return await self.client.patch_flow_schema_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class FlowcontrolApiserverV1beta2PriorityLevelConfigurationManager:
    def __init__(self, client: kubernetes_asyncio.client.FlowcontrolApiserverV1beta2Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta2PriorityLevelConfigurationList:
        return await self.client.list_priority_level_configuration(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1beta2PriorityLevelConfiguration, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta2PriorityLevelConfiguration:
        return await self.client.create_priority_level_configuration(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta2PriorityLevelConfiguration:
        return await self.client.read_priority_level_configuration(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1beta2PriorityLevelConfiguration, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta2PriorityLevelConfiguration:
        return await self.client.replace_priority_level_configuration(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_priority_level_configuration(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta2PriorityLevelConfiguration:
        return await self.client.patch_priority_level_configuration(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class FlowcontrolApiserverV1beta2CollectionPriorityLevelConfigurationManager:
    def __init__(self, client: kubernetes_asyncio.client.FlowcontrolApiserverV1beta2Api) -> None:
        self.client = client
    async def delete(self, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_priority_level_configuration(pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class FlowcontrolApiserverV1beta2PriorityLevelConfigurationStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.FlowcontrolApiserverV1beta2Api) -> None:
        self.client = client
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta2PriorityLevelConfiguration:
        return await self.client.read_priority_level_configuration_status(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1beta2PriorityLevelConfiguration, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta2PriorityLevelConfiguration:
        return await self.client.replace_priority_level_configuration_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta2PriorityLevelConfiguration:
        return await self.client.patch_priority_level_configuration_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class InternalApiserverV1alpha1StorageVersionManager:
    def __init__(self, client: kubernetes_asyncio.client.InternalApiserverV1alpha1Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1alpha1StorageVersionList:
        return await self.client.list_storage_version(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1alpha1StorageVersion, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1alpha1StorageVersion:
        return await self.client.create_storage_version(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1alpha1StorageVersion:
        return await self.client.read_storage_version(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1alpha1StorageVersion, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1alpha1StorageVersion:
        return await self.client.replace_storage_version(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_storage_version(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1alpha1StorageVersion:
        return await self.client.patch_storage_version(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class InternalApiserverV1alpha1CollectionStorageVersionManager:
    def __init__(self, client: kubernetes_asyncio.client.InternalApiserverV1alpha1Api) -> None:
        self.client = client
    async def delete(self, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_storage_version(pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class InternalApiserverV1alpha1StorageVersionStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.InternalApiserverV1alpha1Api) -> None:
        self.client = client
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1alpha1StorageVersion:
        return await self.client.read_storage_version_status(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1alpha1StorageVersion, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1alpha1StorageVersion:
        return await self.client.replace_storage_version_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1alpha1StorageVersion:
        return await self.client.patch_storage_version_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class NetworkingV1IngressClassManager:
    def __init__(self, client: kubernetes_asyncio.client.NetworkingV1Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1IngressClassList:
        return await self.client.list_ingress_class(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1IngressClass, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1IngressClass:
        return await self.client.create_ingress_class(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1IngressClass:
        return await self.client.read_ingress_class(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1IngressClass, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1IngressClass:
        return await self.client.replace_ingress_class(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_ingress_class(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1IngressClass:
        return await self.client.patch_ingress_class(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class NetworkingV1CollectionIngressClassManager:
    def __init__(self, client: kubernetes_asyncio.client.NetworkingV1Api) -> None:
        self.client = client
    async def delete(self, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_ingress_class(pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class NetworkingV1IngressForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.NetworkingV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1IngressList:
        return await self.client.list_ingress_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class NetworkingV1NamespacedIngressManager:
    def __init__(self, client: kubernetes_asyncio.client.NetworkingV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1IngressList:
        return await self.client.list_namespaced_ingress(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1Ingress, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Ingress:
        return await self.client.create_namespaced_ingress(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Ingress:
        return await self.client.read_namespaced_ingress(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1Ingress, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Ingress:
        return await self.client.replace_namespaced_ingress(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_ingress(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1Ingress:
        return await self.client.patch_namespaced_ingress(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class NetworkingV1CollectionNamespacedIngressManager:
    def __init__(self, client: kubernetes_asyncio.client.NetworkingV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_ingress(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class NetworkingV1NamespacedIngressStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.NetworkingV1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Ingress:
        return await self.client.read_namespaced_ingress_status(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1Ingress, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Ingress:
        return await self.client.replace_namespaced_ingress_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1Ingress:
        return await self.client.patch_namespaced_ingress_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class NetworkingV1NamespacedNetworkPolicyManager:
    def __init__(self, client: kubernetes_asyncio.client.NetworkingV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1NetworkPolicyList:
        return await self.client.list_namespaced_network_policy(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1NetworkPolicy, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1NetworkPolicy:
        return await self.client.create_namespaced_network_policy(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1NetworkPolicy:
        return await self.client.read_namespaced_network_policy(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1NetworkPolicy, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1NetworkPolicy:
        return await self.client.replace_namespaced_network_policy(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_network_policy(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1NetworkPolicy:
        return await self.client.patch_namespaced_network_policy(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class NetworkingV1CollectionNamespacedNetworkPolicyManager:
    def __init__(self, client: kubernetes_asyncio.client.NetworkingV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_network_policy(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class NetworkingV1NamespacedNetworkPolicyStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.NetworkingV1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1NetworkPolicy:
        return await self.client.read_namespaced_network_policy_status(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1NetworkPolicy, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1NetworkPolicy:
        return await self.client.replace_namespaced_network_policy_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1NetworkPolicy:
        return await self.client.patch_namespaced_network_policy_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class NetworkingV1NetworkPolicyForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.NetworkingV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1NetworkPolicyList:
        return await self.client.list_network_policy_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class NodeV1RuntimeClassManager:
    def __init__(self, client: kubernetes_asyncio.client.NodeV1Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1RuntimeClassList:
        return await self.client.list_runtime_class(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1RuntimeClass, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1RuntimeClass:
        return await self.client.create_runtime_class(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1RuntimeClass:
        return await self.client.read_runtime_class(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1RuntimeClass, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1RuntimeClass:
        return await self.client.replace_runtime_class(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_runtime_class(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1RuntimeClass:
        return await self.client.patch_runtime_class(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class NodeV1CollectionRuntimeClassManager:
    def __init__(self, client: kubernetes_asyncio.client.NodeV1Api) -> None:
        self.client = client
    async def delete(self, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_runtime_class(pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class NodeV1beta1RuntimeClassManager:
    def __init__(self, client: kubernetes_asyncio.client.NodeV1beta1Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1RuntimeClassList:
        return await self.client.list_runtime_class(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1beta1RuntimeClass, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1RuntimeClass:
        return await self.client.create_runtime_class(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1RuntimeClass:
        return await self.client.read_runtime_class(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1beta1RuntimeClass, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1RuntimeClass:
        return await self.client.replace_runtime_class(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_runtime_class(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1RuntimeClass:
        return await self.client.patch_runtime_class(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class NodeV1beta1CollectionRuntimeClassManager:
    def __init__(self, client: kubernetes_asyncio.client.NodeV1beta1Api) -> None:
        self.client = client
    async def delete(self, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_runtime_class(pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class PolicyV1NamespacedPodDisruptionBudgetManager:
    def __init__(self, client: kubernetes_asyncio.client.PolicyV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1PodDisruptionBudgetList:
        return await self.client.list_namespaced_pod_disruption_budget(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1PodDisruptionBudget, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PodDisruptionBudget:
        return await self.client.create_namespaced_pod_disruption_budget(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PodDisruptionBudget:
        return await self.client.read_namespaced_pod_disruption_budget(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1PodDisruptionBudget, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PodDisruptionBudget:
        return await self.client.replace_namespaced_pod_disruption_budget(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_pod_disruption_budget(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1PodDisruptionBudget:
        return await self.client.patch_namespaced_pod_disruption_budget(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class PolicyV1CollectionNamespacedPodDisruptionBudgetManager:
    def __init__(self, client: kubernetes_asyncio.client.PolicyV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_pod_disruption_budget(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class PolicyV1NamespacedPodDisruptionBudgetStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.PolicyV1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PodDisruptionBudget:
        return await self.client.read_namespaced_pod_disruption_budget_status(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1PodDisruptionBudget, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PodDisruptionBudget:
        return await self.client.replace_namespaced_pod_disruption_budget_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1PodDisruptionBudget:
        return await self.client.patch_namespaced_pod_disruption_budget_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class PolicyV1PodDisruptionBudgetForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.PolicyV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1PodDisruptionBudgetList:
        return await self.client.list_pod_disruption_budget_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class PolicyV1beta1NamespacedPodDisruptionBudgetManager:
    def __init__(self, client: kubernetes_asyncio.client.PolicyV1beta1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1PodDisruptionBudgetList:
        return await self.client.list_namespaced_pod_disruption_budget(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1beta1PodDisruptionBudget, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1PodDisruptionBudget:
        return await self.client.create_namespaced_pod_disruption_budget(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1PodDisruptionBudget:
        return await self.client.read_namespaced_pod_disruption_budget(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1beta1PodDisruptionBudget, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1PodDisruptionBudget:
        return await self.client.replace_namespaced_pod_disruption_budget(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_pod_disruption_budget(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1PodDisruptionBudget:
        return await self.client.patch_namespaced_pod_disruption_budget(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class PolicyV1beta1CollectionNamespacedPodDisruptionBudgetManager:
    def __init__(self, client: kubernetes_asyncio.client.PolicyV1beta1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_pod_disruption_budget(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class PolicyV1beta1NamespacedPodDisruptionBudgetStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.PolicyV1beta1Api) -> None:
        self.client = client
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1PodDisruptionBudget:
        return await self.client.read_namespaced_pod_disruption_budget_status(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1beta1PodDisruptionBudget, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1PodDisruptionBudget:
        return await self.client.replace_namespaced_pod_disruption_budget_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1PodDisruptionBudget:
        return await self.client.patch_namespaced_pod_disruption_budget_status(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class PolicyV1beta1PodDisruptionBudgetForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.PolicyV1beta1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1PodDisruptionBudgetList:
        return await self.client.list_pod_disruption_budget_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class PolicyV1beta1PodSecurityPolicyManager:
    def __init__(self, client: kubernetes_asyncio.client.PolicyV1beta1Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1PodSecurityPolicyList:
        return await self.client.list_pod_security_policy(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1beta1PodSecurityPolicy, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1PodSecurityPolicy:
        return await self.client.create_pod_security_policy(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1PodSecurityPolicy:
        return await self.client.read_pod_security_policy(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1beta1PodSecurityPolicy, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1PodSecurityPolicy:
        return await self.client.replace_pod_security_policy(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1PodSecurityPolicy:
        return await self.client.delete_pod_security_policy(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1PodSecurityPolicy:
        return await self.client.patch_pod_security_policy(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class PolicyV1beta1CollectionPodSecurityPolicyManager:
    def __init__(self, client: kubernetes_asyncio.client.PolicyV1beta1Api) -> None:
        self.client = client
    async def delete(self, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_pod_security_policy(pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class RbacAuthorizationV1ClusterRoleBindingManager:
    def __init__(self, client: kubernetes_asyncio.client.RbacAuthorizationV1Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ClusterRoleBindingList:
        return await self.client.list_cluster_role_binding(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1ClusterRoleBinding, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ClusterRoleBinding:
        return await self.client.create_cluster_role_binding(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ClusterRoleBinding:
        return await self.client.read_cluster_role_binding(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1ClusterRoleBinding, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ClusterRoleBinding:
        return await self.client.replace_cluster_role_binding(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_cluster_role_binding(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ClusterRoleBinding:
        return await self.client.patch_cluster_role_binding(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class RbacAuthorizationV1CollectionClusterRoleBindingManager:
    def __init__(self, client: kubernetes_asyncio.client.RbacAuthorizationV1Api) -> None:
        self.client = client
    async def delete(self, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_cluster_role_binding(pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class RbacAuthorizationV1ClusterRoleManager:
    def __init__(self, client: kubernetes_asyncio.client.RbacAuthorizationV1Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ClusterRoleList:
        return await self.client.list_cluster_role(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1ClusterRole, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ClusterRole:
        return await self.client.create_cluster_role(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ClusterRole:
        return await self.client.read_cluster_role(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1ClusterRole, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1ClusterRole:
        return await self.client.replace_cluster_role(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_cluster_role(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1ClusterRole:
        return await self.client.patch_cluster_role(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class RbacAuthorizationV1CollectionClusterRoleManager:
    def __init__(self, client: kubernetes_asyncio.client.RbacAuthorizationV1Api) -> None:
        self.client = client
    async def delete(self, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_cluster_role(pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class RbacAuthorizationV1NamespacedRoleBindingManager:
    def __init__(self, client: kubernetes_asyncio.client.RbacAuthorizationV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1RoleBindingList:
        return await self.client.list_namespaced_role_binding(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1RoleBinding, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1RoleBinding:
        return await self.client.create_namespaced_role_binding(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1RoleBinding:
        return await self.client.read_namespaced_role_binding(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1RoleBinding, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1RoleBinding:
        return await self.client.replace_namespaced_role_binding(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_role_binding(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1RoleBinding:
        return await self.client.patch_namespaced_role_binding(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class RbacAuthorizationV1CollectionNamespacedRoleBindingManager:
    def __init__(self, client: kubernetes_asyncio.client.RbacAuthorizationV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_role_binding(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class RbacAuthorizationV1NamespacedRoleManager:
    def __init__(self, client: kubernetes_asyncio.client.RbacAuthorizationV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1RoleList:
        return await self.client.list_namespaced_role(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1Role, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Role:
        return await self.client.create_namespaced_role(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Role:
        return await self.client.read_namespaced_role(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1Role, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Role:
        return await self.client.replace_namespaced_role(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_role(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1Role:
        return await self.client.patch_namespaced_role(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class RbacAuthorizationV1CollectionNamespacedRoleManager:
    def __init__(self, client: kubernetes_asyncio.client.RbacAuthorizationV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_role(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class RbacAuthorizationV1RoleBindingForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.RbacAuthorizationV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1RoleBindingList:
        return await self.client.list_role_binding_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class RbacAuthorizationV1RoleForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.RbacAuthorizationV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1RoleList:
        return await self.client.list_role_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class SchedulingV1PriorityClassManager:
    def __init__(self, client: kubernetes_asyncio.client.SchedulingV1Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1PriorityClassList:
        return await self.client.list_priority_class(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1PriorityClass, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PriorityClass:
        return await self.client.create_priority_class(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PriorityClass:
        return await self.client.read_priority_class(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1PriorityClass, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1PriorityClass:
        return await self.client.replace_priority_class(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_priority_class(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1PriorityClass:
        return await self.client.patch_priority_class(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class SchedulingV1CollectionPriorityClassManager:
    def __init__(self, client: kubernetes_asyncio.client.SchedulingV1Api) -> None:
        self.client = client
    async def delete(self, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_priority_class(pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class StorageV1CsiDriverManager:
    def __init__(self, client: kubernetes_asyncio.client.StorageV1Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1CSIDriverList:
        return await self.client.list_csi_driver(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1CSIDriver, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CSIDriver:
        return await self.client.create_csi_driver(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CSIDriver:
        return await self.client.read_csi_driver(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1CSIDriver, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CSIDriver:
        return await self.client.replace_csi_driver(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CSIDriver:
        return await self.client.delete_csi_driver(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1CSIDriver:
        return await self.client.patch_csi_driver(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class StorageV1CollectionCsiDriverManager:
    def __init__(self, client: kubernetes_asyncio.client.StorageV1Api) -> None:
        self.client = client
    async def delete(self, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_csi_driver(pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class StorageV1CsiNodeManager:
    def __init__(self, client: kubernetes_asyncio.client.StorageV1Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1CSINodeList:
        return await self.client.list_csi_node(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1CSINode, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CSINode:
        return await self.client.create_csi_node(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CSINode:
        return await self.client.read_csi_node(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1CSINode, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CSINode:
        return await self.client.replace_csi_node(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CSINode:
        return await self.client.delete_csi_node(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1CSINode:
        return await self.client.patch_csi_node(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class StorageV1CollectionCsiNodeManager:
    def __init__(self, client: kubernetes_asyncio.client.StorageV1Api) -> None:
        self.client = client
    async def delete(self, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_csi_node(pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class StorageV1CsiStorageCapacityForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.StorageV1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1CSIStorageCapacityList:
        return await self.client.list_csi_storage_capacity_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class StorageV1NamespacedCsiStorageCapacityManager:
    def __init__(self, client: kubernetes_asyncio.client.StorageV1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1CSIStorageCapacityList:
        return await self.client.list_namespaced_csi_storage_capacity(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1CSIStorageCapacity, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CSIStorageCapacity:
        return await self.client.create_namespaced_csi_storage_capacity(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CSIStorageCapacity:
        return await self.client.read_namespaced_csi_storage_capacity(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1CSIStorageCapacity, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1CSIStorageCapacity:
        return await self.client.replace_namespaced_csi_storage_capacity(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_csi_storage_capacity(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1CSIStorageCapacity:
        return await self.client.patch_namespaced_csi_storage_capacity(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class StorageV1CollectionNamespacedCsiStorageCapacityManager:
    def __init__(self, client: kubernetes_asyncio.client.StorageV1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_csi_storage_capacity(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class StorageV1StorageClassManager:
    def __init__(self, client: kubernetes_asyncio.client.StorageV1Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1StorageClassList:
        return await self.client.list_storage_class(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1StorageClass, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1StorageClass:
        return await self.client.create_storage_class(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1StorageClass:
        return await self.client.read_storage_class(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1StorageClass, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1StorageClass:
        return await self.client.replace_storage_class(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1StorageClass:
        return await self.client.delete_storage_class(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1StorageClass:
        return await self.client.patch_storage_class(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class StorageV1CollectionStorageClassManager:
    def __init__(self, client: kubernetes_asyncio.client.StorageV1Api) -> None:
        self.client = client
    async def delete(self, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_storage_class(pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class StorageV1VolumeAttachmentManager:
    def __init__(self, client: kubernetes_asyncio.client.StorageV1Api) -> None:
        self.client = client
    async def list(self, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1VolumeAttachmentList:
        return await self.client.list_volume_attachment(pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, body: kubernetes_asyncio.client.V1VolumeAttachment, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1VolumeAttachment:
        return await self.client.create_volume_attachment(body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1VolumeAttachment:
        return await self.client.read_volume_attachment(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1VolumeAttachment, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1VolumeAttachment:
        return await self.client.replace_volume_attachment(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1VolumeAttachment:
        return await self.client.delete_volume_attachment(name=name, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1VolumeAttachment:
        return await self.client.patch_volume_attachment(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class StorageV1CollectionVolumeAttachmentManager:
    def __init__(self, client: kubernetes_asyncio.client.StorageV1Api) -> None:
        self.client = client
    async def delete(self, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_volume_attachment(pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
class StorageV1VolumeAttachmentStatusManager:
    def __init__(self, client: kubernetes_asyncio.client.StorageV1Api) -> None:
        self.client = client
    async def read(self, name: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1VolumeAttachment:
        return await self.client.read_volume_attachment_status(name=name, pretty=pretty)
    async def replace(self, name: str, body: kubernetes_asyncio.client.V1VolumeAttachment, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1VolumeAttachment:
        return await self.client.replace_volume_attachment_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def patch(self, name: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1VolumeAttachment:
        return await self.client.patch_volume_attachment_status(name=name, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class StorageV1beta1CsiStorageCapacityForAllNamespacesManager:
    def __init__(self, client: kubernetes_asyncio.client.StorageV1beta1Api) -> None:
        self.client = client
    async def list(self, *, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, pretty: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1CSIStorageCapacityList:
        return await self.client.list_csi_storage_capacity_for_all_namespaces(allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, pretty=pretty, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
class StorageV1beta1NamespacedCsiStorageCapacityManager:
    def __init__(self, client: kubernetes_asyncio.client.StorageV1beta1Api) -> None:
        self.client = client
    async def list(self, namespace: str, *, pretty: typing.Optional[str] = None, allow_watch_bookmarks: typing.Optional[bool] = None, _continue: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None, watch: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1CSIStorageCapacityList:
        return await self.client.list_namespaced_csi_storage_capacity(namespace=namespace, pretty=pretty, allow_watch_bookmarks=allow_watch_bookmarks, _continue=_continue, field_selector=field_selector, label_selector=label_selector, limit=limit, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds, watch=watch)
    async def create(self, namespace: str, body: kubernetes_asyncio.client.V1beta1CSIStorageCapacity, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1CSIStorageCapacity:
        return await self.client.create_namespaced_csi_storage_capacity(namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def read(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1CSIStorageCapacity:
        return await self.client.read_namespaced_csi_storage_capacity(name=name, namespace=namespace, pretty=pretty)
    async def replace(self, name: str, namespace: str, body: kubernetes_asyncio.client.V1beta1CSIStorageCapacity, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1beta1CSIStorageCapacity:
        return await self.client.replace_namespaced_csi_storage_capacity(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation)
    async def delete(self, name: str, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, dry_run: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_namespaced_csi_storage_capacity(name=name, namespace=namespace, pretty=pretty, body=body, dry_run=dry_run, grace_period_seconds=grace_period_seconds, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy)
    async def patch(self, name: str, namespace: str, body: typing.Any, *, pretty: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_manager: typing.Optional[str] = None, field_validation: typing.Optional[str] = None, force: typing.Optional[bool] = None) -> kubernetes_asyncio.client.V1beta1CSIStorageCapacity:
        return await self.client.patch_namespaced_csi_storage_capacity(name=name, namespace=namespace, body=body, pretty=pretty, dry_run=dry_run, field_manager=field_manager, field_validation=field_validation, force=force)
class StorageV1beta1CollectionNamespacedCsiStorageCapacityManager:
    def __init__(self, client: kubernetes_asyncio.client.StorageV1beta1Api) -> None:
        self.client = client
    async def delete(self, namespace: str, *, pretty: typing.Optional[str] = None, body: typing.Optional[kubernetes_asyncio.client.V1DeleteOptions] = None, _continue: typing.Optional[str] = None, dry_run: typing.Optional[str] = None, field_selector: typing.Optional[str] = None, grace_period_seconds: typing.Optional[int] = None, label_selector: typing.Optional[str] = None, limit: typing.Optional[int] = None, orphan_dependents: typing.Optional[bool] = None, propagation_policy: typing.Optional[str] = None, resource_version: typing.Optional[str] = None, resource_version_match: typing.Optional[str] = None, timeout_seconds: typing.Optional[int] = None) -> kubernetes_asyncio.client.V1Status:
        return await self.client.delete_collection_namespaced_csi_storage_capacity(namespace=namespace, pretty=pretty, body=body, _continue=_continue, dry_run=dry_run, field_selector=field_selector, grace_period_seconds=grace_period_seconds, label_selector=label_selector, limit=limit, orphan_dependents=orphan_dependents, propagation_policy=propagation_policy, resource_version=resource_version, resource_version_match=resource_version_match, timeout_seconds=timeout_seconds)
